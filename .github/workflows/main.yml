name: Deploy Keycloak to ECS (downtime replace)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: ap-southeast-2
  ACCOUNT_ID: "533267398655"
  ECR_REPOSITORY: "appzgatenz/topsale/identity-centre"
  CLUSTER: "IDENTITY-CENTRE-NONPROD"
  SERVICE: "IDENTITY-CENTRE-NONPROD-SERVICE"
  # 需为“任务定义里容器的 name”。若留空且仅 1 个容器，将自动检测。
  CONTAINER_NAME: "IDENTITY-CENTRE-NONPROD-TD"

concurrency:
  group: ecs-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 暂用 AK/SK；后续建议改为 OIDC 角色
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build base image
        run: |
          set -euo pipefail
          docker build -t identity-centre-base:latest -f Dockerfile_base .

      - name: Build app image (keycloak)
        run: |
          set -euo pipefail
          docker build -t keycloak:latest -f Dockerfile .

      - name: Set TAG
        id: meta
        run: |
          set -euo pipefail
          echo "TAG=$(date -u +'%Y%m%d-%H%M')-${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      - name: Tag and push to ECR
        env:
          REPO_URI: ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          TAG: ${{ steps.meta.outputs.TAG }}
        run: |
          set -euo pipefail
          docker tag keycloak:latest "${REPO_URI}:latest"
          docker tag keycloak:latest "${REPO_URI}:${TAG}"
          docker push "${REPO_URI}:latest"
          docker push "${REPO_URI}:${TAG}"

      - name: Resolve image digest
        id: digest
        env:
          TAG: ${{ steps.meta.outputs.TAG }}
        run: |
          set -euo pipefail
          DIGEST=$(aws ecr batch-get-image \
            --region "${AWS_REGION}" \
            --repository-name "${ECR_REPOSITORY}" \
            --image-ids imageTag="${TAG}" \
            --query 'images[0].imageId.imageDigest' \
            --output text)
          if [ -z "${DIGEST}" ] || [ "${DIGEST}" = "None" ]; then
            echo "Failed to get image digest for tag ${TAG}"
            exit 1
          fi
          echo "DIGEST=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Resolved digest: ${DIGEST}"

      - name: Install jq
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Register new task definition revision (strip nulls, replace image)
        id: register
        env:
          CLUSTER: ${{ env.CLUSTER }}
          SERVICE: ${{ env.SERVICE }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          REPO_URI: ${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          DIGEST: ${{ steps.digest.outputs.DIGEST }}
        run: |
          set -euo pipefail

          TD_ARN=$(aws ecs describe-services \
            --region "${AWS_REGION}" \
            --cluster "${CLUSTER}" \
            --services "${SERVICE}" \
            --query "services[0].taskDefinition" \
            --output text)
          echo "Current TD: ${TD_ARN}"

          TD_ALL=$(aws ecs describe-task-definition \
            --region "${AWS_REGION}" \
            --task-definition "${TD_ARN}" \
            --output json)

          # 仅保留允许的顶级字段，并递归删除所有 null
          BASE=$(echo "${TD_ALL}" | jq '
            .taskDefinition
            | {
                family, taskRoleArn, executionRoleArn, networkMode,
                containerDefinitions, volumes, placementConstraints,
                requiresCompatibilities, cpu, memory, runtimePlatform,
                pidMode, ipcMode, proxyConfiguration, inferenceAccelerators, ephemeralStorage
              }
            | del(.. | nulls)
          ')

          # 处理容器名：若未设置且仅 1 个容器，自动选择；若设置但不存在且仅 1 个容器，也自动选择；多个容器则校验
          CNT=$(echo "${BASE}" | jq '.containerDefinitions | length')
          TARGET="${CONTAINER_NAME}"
          if [ -z "${TARGET}" ]; then
            if [ "${CNT}" -eq 1 ]; then
              TARGET=$(echo "${BASE}" | jq -r '.containerDefinitions[0].name')
              echo "Auto-detected container: ${TARGET}"
            else
              echo "ERROR: Multiple containers found; please set CONTAINER_NAME to one of:"
              echo "${BASE}" | jq -r '.containerDefinitions[].name'
              exit 1
            fi
          else
            if echo "${BASE}" | jq -e --arg n "${TARGET}" 'any(.containerDefinitions[].name; . == $n)' >/dev/null; then
              echo "Using container: ${TARGET}"
            else
              if [ "${CNT}" -eq 1 ]; then
                TARGET=$(echo "${BASE}" | jq -r '.containerDefinitions[0].name')
                echo "WARN: CONTAINER_NAME not found; auto-selected single container: ${TARGET}"
              else
                echo "ERROR: CONTAINER_NAME \"${TARGET}\" not found. Available containers:"
                echo "${BASE}" | jq -r '.containerDefinitions[].name'
                exit 1
              fi
            fi
          fi

          NEW_IMAGE="${REPO_URI}@${DIGEST}"  # 不可变部署
          NEW_TD=$(echo "${BASE}" | jq --arg name "${TARGET}" --arg img "${NEW_IMAGE}" '
            .containerDefinitions |= (map(
              if .name == $name then .image = $img else . end
            ))
          ')

          # 健全性检查：确认替换生效
          echo "${NEW_TD}" | jq -e --arg name "${TARGET}" --arg img "${NEW_IMAGE}" \
            'any(.containerDefinitions[]; .name==$name and .image==$img)' >/dev/null \
            || { echo "Image replacement failed"; exit 1; }

          OUT=$(aws ecs register-task-definition \
            --region "${AWS_REGION}" \
            --cli-input-json "${NEW_TD}")
          NEW_TD_ARN=$(echo "${OUT}" | jq -r '.taskDefinition.taskDefinitionArn')

          if [ -z "${NEW_TD_ARN}" ] || [ "${NEW_TD_ARN}" = "null" ]; then
            echo "Failed to register new task definition"
            echo "${OUT}"
            exit 1
          fi
          echo "NEW_TD_ARN=${NEW_TD_ARN}" >> "$GITHUB_OUTPUT"
          echo "Registered: ${NEW_TD_ARN}"

      - name: Scale service to 0 (downtime replace)
        run: |
          set -euo pipefail
          aws ecs update-service \
            --region "${AWS_REGION}" \
            --cluster "${CLUSTER}" \
            --service "${SERVICE}" \
            --desired-count 0
          aws ecs wait services-stable \
            --region "${AWS_REGION}" \
            --cluster "${CLUSTER}" \
            --services "${SERVICE}"
          echo "Service scaled to 0."

      - name: Update service to new task definition
        run: |
          set -euo pipefail
          aws ecs update-service \
            --region "${AWS_REGION}" \
            --cluster "${CLUSTER}" \
            --service "${SERVICE}" \
            --task-definition "${{ steps.register.outputs.NEW_TD_ARN }}" \
            --deployment-configuration minimumHealthyPercent=0,maximumPercent=100
          echo "Service updated to new TD."

      - name: Scale service to 1 and wait
        run: |
          set -euo pipefail
          aws ecs update-service \
            --region "${AWS_REGION}" \
            --cluster "${CLUSTER}" \
            --service "${SERVICE}" \
            --desired-count 1
          aws ecs wait services-stable \
            --region "${AWS_REGION}" \
            --cluster "${CLUSTER}" \
            --services "${SERVICE}"
          echo "Service scaled to 1 and stabilized."

      - name: Show last 10 service events (debug)
        if: always()
        run: |
          set -euo pipefail
          aws ecs describe-services \
            --region "${AWS_REGION}" \
            --cluster "${CLUSTER}" \
            --services "${SERVICE}" \
            --query 'services[0].events[0:10]'